<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>åœ°åœ–ç³»çµ± - ä¿®æ­£ç‰ˆ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ—ºï¸</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html {
            touch-action: manipulation;
            -ms-touch-action: manipulation;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            touch-action: none;
            -webkit-text-size-adjust: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #app {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            touch-action: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
            touch-action: none;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            width: 50px;
            height: 50px;
            border-radius: 25px;
            border: none;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            font-size: 24px;
            cursor: pointer;
            touch-action: manipulation;
            color: #334155;
            font-weight: 600;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background: rgba(255,255,255,0.95);
            color: #334155;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .zoom-level {
            color: #4ade80;
            font-weight: bold;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #475569;
            font-size: 18px;
            z-index: 2000;
            text-align: center;
        }

        iframe {
            border: none;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="app">
        <canvas id="canvas"></canvas>
        <div class="loading" id="loading">è¼‰å…¥ä¸­...</div>

        <div class="controls">
            <button class="btn" id="zoomIn">+</button>
            <button class="btn" id="zoomOut">âˆ’</button>
            <button class="btn" id="reset">âŸ²</button>
            <button class="btn" id="reload">ğŸ”„</button>
        </div>

        <div class="info">
            ç¸®æ”¾: <span class="zoom-level" id="zoomLevel">100%</span><br>
            <span id="layerInfo">åŸºç¤åœ–å±¤</span>
        </div>
    </div>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let canvas, ctx;
        let svgImageBasic = null;  // åŸºç¤åœ–å±¤ (g2 + svg_655 + svg_30)
        let svgImageFull = null;   // å®Œæ•´åœ–å±¤ (å…¨éƒ¨)
        let scale = 0.33; // åˆå§‹ç¸®æ”¾è¨­ç‚º33%
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        // è§¸æ§è¿½è¹¤
        let touches = [];
        let lastDistance = 0;

        // è¼‰å…¥ä¸¦ä¿®æ”¹SVG
        async function loadSVG() {
            try {
                // è¼‰å…¥SVGæ–‡æœ¬ï¼ˆæ·»åŠ æ™‚é–“æˆ³å¼·åˆ¶é‡æ–°è¼‰å…¥ï¼‰
                const timestamp = new Date().getTime();
                const response = await fetch(`svg (1223).svg?t=${timestamp}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const svgText = await response.text();

                console.log('SVGè¼‰å…¥æˆåŠŸï¼Œæª”æ¡ˆå¤§å°:', svgText.length);
                document.getElementById('loading').textContent = 'è™•ç†SVGä¸­...';

                // æª¢æŸ¥g1å…ƒç´ æ˜¯å¦å­˜åœ¨
                const g1Match = svgText.match(/<g[^>]*id="g1"[^>]*>/);
                if (!g1Match) {
                    console.warn('æœªæ‰¾åˆ°g1å…ƒç´ ï¼Œä½¿ç”¨åŸå§‹SVG');
                    // å¦‚æœæ²’æœ‰g1å…ƒç´ ï¼Œå…©å€‹ç‰ˆæœ¬éƒ½ä½¿ç”¨åŸå§‹SVG
                    await Promise.all([
                        loadImageFromSvg(svgText, 'basic'),
                        loadImageFromSvg(svgText, 'full')
                    ]);
                } else {
                    console.log('æ‰¾åˆ°g1å…ƒç´ :', g1Match[0]);

                    // å‰µå»ºåŸºç¤åœ–å±¤ç‰ˆæœ¬ (å®Œå…¨ç§»é™¤g1å…§å®¹)
                    const basicSvgText = svgText.replace(
                        /<g[^>]*id="g1"[^>]*>[\s\S]*?<\/g>/,
                        '<g id="g1"></g>'
                    );

                    console.log('Basic SVG è™•ç†å®Œæˆï¼Œå¤§å°:', basicSvgText.length);
                    console.log('Basic SVG g1æª¢æŸ¥:', basicSvgText.includes('<g id="g1"></g>'));

                    // å‰µå»ºå®Œæ•´åœ–å±¤ç‰ˆæœ¬ (æš«æ™‚ä½¿ç”¨åŸå§‹ç‰ˆæœ¬ï¼Œä¸ä¿®æ”¹é¡è‰²)
                    let fullSvgText = svgText;
                    console.log('Full SVG ä½¿ç”¨åŸå§‹ç‰ˆæœ¬ï¼Œå¤§å°:', fullSvgText.length);

                    // è¼‰å…¥å…©å€‹ç‰ˆæœ¬çš„åœ–åƒ
                    await Promise.all([
                        loadImageFromSvg(basicSvgText, 'basic'),
                        loadImageFromSvg(fullSvgText, 'full')
                    ]);
                }

                document.getElementById('loading').style.display = 'none';
                updateUI();

                // å¼·åˆ¶å¤šæ¬¡é‡ç¹ªç¢ºä¿æ›´æ–°
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => requestAnimationFrame(draw), i * 100);
                }

            } catch (error) {
                console.error('è¼‰å…¥SVGå¤±æ•—:', error);
                document.getElementById('loading').textContent = 'è¼‰å…¥å¤±æ•—: ' + error.message;

                // å¦‚æœä¿®æ”¹ç‰ˆæœ¬å¤±æ•—ï¼Œå˜—è©¦è¼‰å…¥åŸå§‹ç‰ˆæœ¬
                try {
                    const response = await fetch('svg (1223).svg');
                    const svgText = await response.text();
                    await loadImageFromSvg(svgText, 'fallback');
                    svgImageBasic = svgImageFull;
                    document.getElementById('loading').style.display = 'none';
                    updateUI();
                    requestAnimationFrame(draw);
                } catch (fallbackError) {
                    console.error('å¾Œå‚™è¼‰å…¥ä¹Ÿå¤±æ•—:', fallbackError);
                }
            }
        }

        // å¾SVGæ–‡æœ¬å‰µå»ºåœ–åƒ
        function loadImageFromSvg(svgText, type) {
            return new Promise((resolve, reject) => {
                try {
                    // æª¢æŸ¥SVGå…§å®¹æ˜¯å¦æœ‰æ•ˆ
                    if (!svgText || !svgText.includes('<svg')) {
                        throw new Error(`ç„¡æ•ˆçš„SVGå…§å®¹ (${type})`);
                    }

                    // ç¢ºä¿SVGæœ‰æ­£ç¢ºçš„å‘½åç©ºé–“
                    let cleanSvgText = svgText;
                    if (!cleanSvgText.includes('xmlns="http://www.w3.org/2000/svg"')) {
                        cleanSvgText = cleanSvgText.replace(
                            /<svg([^>]*)>/,
                            '<svg$1 xmlns="http://www.w3.org/2000/svg">'
                        );
                    }

                    // æ·»åŠ å”¯ä¸€IDé¿å…ç·©å­˜
                    const uniqueId = Date.now() + Math.random();
                    cleanSvgText = cleanSvgText.replace(
                        /<svg([^>]*)>/,
                        `<svg$1 data-reload="${uniqueId}">`
                    );

                    const blob = new Blob([cleanSvgText], {
                        type: 'image/svg+xml;charset=utf-8'
                    });
                    const url = URL.createObjectURL(blob);

                    console.log(`å‰µå»º${type}åœ–åƒURL:`, url);

                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    img.onload = function() {
                        console.log(`${type}åœ–åƒè¼‰å…¥æˆåŠŸ:`, img.width, 'x', img.height);

                        if (type === 'basic') {
                            svgImageBasic = img;
                        } else if (type === 'full') {
                            svgImageFull = img;
                        } else if (type === 'fallback') {
                            svgImageFull = img;
                        }

                        URL.revokeObjectURL(url);

                        // åœ–åƒè¼‰å…¥å®Œæˆå¾Œç«‹å³é‡ç¹ª
                        if (ctx) {
                            requestAnimationFrame(draw);
                        }

                        resolve();
                    };

                    img.onerror = function(e) {
                        console.error(`${type}åœ–åƒè¼‰å…¥éŒ¯èª¤:`, e);
                        URL.revokeObjectURL(url);
                        reject(new Error(`è¼‰å…¥${type}åœ–åƒå¤±æ•—: ${e.message || 'æœªçŸ¥éŒ¯èª¤'}`));
                    };

                    // è¨­ç½®è¶…æ™‚
                    setTimeout(() => {
                        if (!img.complete) {
                            URL.revokeObjectURL(url);
                            reject(new Error(`è¼‰å…¥${type}åœ–åƒè¶…æ™‚`));
                        }
                    }, 10000);

                    img.src = url;

                } catch (error) {
                    console.error(`å‰µå»º${type}åœ–åƒæ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                    reject(error);
                }
            });
        }

        // åˆå§‹åŒ–Canvas
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // è¨­å®šCanvaså¤§å°
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                draw();
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // è¨»å†Šäº‹ä»¶
            setupEventHandlers();
        }

        // è¨­å®šäº‹ä»¶è™•ç†å™¨
        function setupEventHandlers() {
            // å®Œå…¨é˜»æ­¢é è¨­è¡Œç‚º
            const preventDefaults = (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            };

            // é˜»æ­¢æ‰€æœ‰å¯èƒ½çš„ç¸®æ”¾è¡Œç‚º
            document.addEventListener('gesturestart', preventDefaults, false);
            document.addEventListener('gesturechange', preventDefaults, false);
            document.addEventListener('gestureend', preventDefaults, false);

            // è§¸æ§äº‹ä»¶
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            canvas.addEventListener('touchcancel', handleTouchEnd, {passive: false});

            // æ»‘é¼ äº‹ä»¶ï¼ˆæ¡Œé¢æ”¯æ´ï¼‰
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, {passive: false});

            // æŒ‰éˆ•äº‹ä»¶
            document.getElementById('zoomIn').addEventListener('click', () => {
                scale = Math.min(5, scale * 1.2);
                updateUI();
                draw();
            });

            document.getElementById('zoomOut').addEventListener('click', () => {
                scale = Math.max(0.2, scale / 1.2);
                updateUI();
                draw();
            });

            document.getElementById('reset').addEventListener('click', () => {
                scale = 0.33;  // é‡ç½®åˆ°33%
                translateX = 0;
                translateY = 0;
                updateUI();
                draw();
            });

            document.getElementById('reload').addEventListener('click', async () => {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'é‡æ–°è¼‰å…¥SVG...';

                try {
                    // æ¸…é™¤èˆŠçš„åœ–åƒ
                    svgImageBasic = null;
                    svgImageFull = null;

                    // æ¸…é™¤Canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // é‡æ–°è¼‰å…¥SVG
                    await loadSVG();

                    // å¼·åˆ¶é‡ç¹ª
                    requestAnimationFrame(draw);

                    console.log('SVGé‡æ–°è¼‰å…¥å®Œæˆ');
                } catch (error) {
                    console.error('é‡æ–°è¼‰å…¥å¤±æ•—:', error);
                    document.getElementById('loading').textContent = 'é‡æ–°è¼‰å…¥å¤±æ•—';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 2000);
                }
            });

            // é˜»æ­¢é›™æ“Šç¸®æ”¾
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(e) {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);

            // é˜»æ­¢æåˆç¸®æ”¾
            document.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, {passive: false});
        }

        // è§¸æ§é–‹å§‹
        function handleTouchStart(e) {
            e.preventDefault();
            e.stopPropagation();

            touches = Array.from(e.touches);

            if (touches.length === 1) {
                // å–®æŒ‡ - æ‹–æ›³
                isDragging = true;
                lastX = touches[0].clientX;
                lastY = touches[0].clientY;
                canvas.classList.add('grabbing');
            } else if (touches.length === 2) {
                // é›™æŒ‡ - ç¸®æ”¾
                isDragging = false;
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                lastDistance = Math.hypot(dx, dy);
                console.log('Touch start - 2 fingers, initial distance:', lastDistance);
            }

            return false;
        }

        // è§¸æ§ç§»å‹•
        function handleTouchMove(e) {
            e.preventDefault();
            e.stopPropagation();

            touches = Array.from(e.touches);

            if (touches.length === 1 && isDragging) {
                // å–®æŒ‡æ‹–æ›³
                const dx = touches[0].clientX - lastX;
                const dy = touches[0].clientY - lastY;

                translateX += dx;
                translateY += dy;

                lastX = touches[0].clientX;
                lastY = touches[0].clientY;

                draw();
            } else if (touches.length === 2) {
                // é›™æŒ‡ç¸®æ”¾ - ä¿®æ­£è¨ˆç®—é‚è¼¯
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                const distance = Math.hypot(dx, dy);

                if (lastDistance > 0) {
                    // è¨ˆç®—ç¸®æ”¾å› å­
                    const scaleFactor = distance / lastDistance;
                    const newScale = Math.max(0.2, Math.min(5, scale * scaleFactor));

                    // è¨ˆç®—è§¸æ§ä¸­å¿ƒé»ï¼ˆè¢å¹•åº§æ¨™ï¼‰
                    const centerX = (touches[0].clientX + touches[1].clientX) / 2;
                    const centerY = (touches[0].clientY + touches[1].clientY) / 2;

                    // è½‰æ›ç‚ºCanvasç›¸å°åº§æ¨™
                    const rect = canvas.getBoundingClientRect();
                    const canvasCenterX = centerX - rect.left;
                    const canvasCenterY = centerY - rect.top;

                    // è¨ˆç®—ç¸®æ”¾å‰åœ¨ä¸–ç•Œåº§æ¨™ä¸­çš„é»
                    const worldX = (canvasCenterX - canvas.width / 2 - translateX) / scale;
                    const worldY = (canvasCenterY - canvas.height / 2 - translateY) / scale;

                    // æ›´æ–°ç¸®æ”¾
                    scale = newScale;

                    // è¨ˆç®—æ–°çš„åç§»ï¼Œä¿æŒä¸–ç•Œåº§æ¨™é»åœ¨è§¸æ§ä¸­å¿ƒ
                    translateX = canvasCenterX - canvas.width / 2 - worldX * scale;
                    translateY = canvasCenterY - canvas.height / 2 - worldY * scale;

                    updateUI();
                    draw();

                    console.log('Scale:', scale.toFixed(2), 'Center:', canvasCenterX.toFixed(0), canvasCenterY.toFixed(0));
                }

                lastDistance = distance;
            }

            return false;
        }

        // è§¸æ§çµæŸ
        function handleTouchEnd(e) {
            e.preventDefault();
            e.stopPropagation();

            touches = Array.from(e.touches);

            if (touches.length === 0) {
                // æ‰€æœ‰æ‰‹æŒ‡é›¢é–‹
                isDragging = false;
                canvas.classList.remove('grabbing');
                lastDistance = 0;
                console.log('All touches ended');
            } else if (touches.length === 1) {
                // å¾é›™æŒ‡è®Šç‚ºå–®æŒ‡ - åˆ‡æ›åˆ°æ‹–æ›³æ¨¡å¼
                isDragging = true;
                lastX = touches[0].clientX;
                lastY = touches[0].clientY;
                lastDistance = 0;
                console.log('Switched to single touch');
            } else if (touches.length === 2) {
                // ä»ç„¶æ˜¯é›™æŒ‡ - é‡æ–°è¨ˆç®—è·é›¢
                const dx = touches[1].clientX - touches[0].clientX;
                const dy = touches[1].clientY - touches[0].clientY;
                lastDistance = Math.hypot(dx, dy);
                console.log('Still 2 fingers, distance:', lastDistance);
            }

            return false;
        }

        // æ»‘é¼ äº‹ä»¶
        function handleMouseDown(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.classList.add('grabbing');
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            translateX += dx;
            translateY += dy;

            lastX = e.clientX;
            lastY = e.clientY;

            draw();
        }

        function handleMouseUp() {
            isDragging = false;
            canvas.classList.remove('grabbing');
        }

        function handleWheel(e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;

            // ä»¥æ»‘é¼ ä½ç½®ç‚ºä¸­å¿ƒç¸®æ”¾
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            translateX -= (x - canvas.width / 2) * (delta - 1);
            translateY -= (y - canvas.height / 2) * (delta - 1);

            scale = Math.max(0.2, Math.min(5, newScale));

            updateUI();
            draw();
        }

        // ç¹ªè£½
        function draw() {
            if (!ctx) return;

            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // å¡«å……æ·¡è‰²èƒŒæ™¯æé«˜å°æ¯”åº¦
            ctx.fillStyle = '#f1f5f9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ä¿å­˜ç‹€æ…‹
            ctx.save();

            // æ‡‰ç”¨è®Šæ›
            ctx.translate(canvas.width / 2 + translateX, canvas.height / 2 + translateY);
            ctx.scale(scale, scale);

            if (scale >= 0.45) {
                // 45%ä»¥ä¸Šï¼šç¹ªè£½å®Œæ•´åœ–å±¤ï¼ˆæš«æ™‚ä½¿ç”¨åŸè‰²ï¼Œå¾ŒçºŒå¯åŠ ç™½è‰²æ•ˆæœï¼‰
                if (svgImageFull) {
                    ctx.drawImage(svgImageFull, -svgImageFull.width / 2, -svgImageFull.height / 2);
                }
            } else {
                // 45%ä»¥ä¸‹ï¼šé¡¯ç¤ºåŸºç¤åœ–å±¤
                if (svgImageBasic) {
                    ctx.drawImage(svgImageBasic, -svgImageBasic.width / 2, -svgImageBasic.height / 2);
                }
            }

            // æ¢å¾©ç‹€æ…‹
            ctx.restore();
        }

        // æ›´æ–°UI
        function updateUI() {
            const zoomPercent = Math.round(scale * 100);
            document.getElementById('zoomLevel').textContent = zoomPercent + '%';

            // åœ–å±¤é‚è¼¯ - 45%ä»¥ä¸Šé¡¯ç¤ºå…¨éƒ¨åœ–å±¤
            const layerInfo = document.getElementById('layerInfo');
            if (scale >= 0.45) {
                layerInfo.textContent = 'å…¨éƒ¨åœ–å±¤ (g2+g1+æ¨™è¨˜)';
                layerInfo.style.color = '#4ade80';
            } else {
                layerInfo.textContent = 'åŸºç¤åœ–å±¤ (g2+æ¨™è¨˜)';
                layerInfo.style.color = '#94a3b8';
            }
        }

        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            initCanvas();
            loadSVG();
            updateUI();

            // å®Œå…¨é˜»æ­¢é é¢ç¸®æ”¾
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, {passive: false});

            // é˜»æ­¢iOSçš„å½ˆæ€§æ»¾å‹•
            document.body.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, {passive: false});

            // éµç›¤å¿«æ·éµ
            document.addEventListener('keydown', function(e) {
                if (e.key === 'r' || e.key === 'R') {
                    document.getElementById('reload').click();
                } else if (e.key === ' ') {
                    e.preventDefault();
                    document.getElementById('reset').click();
                }
            });
        });

        // æª¢æŸ¥ç’°å¢ƒ
        if (location.protocol === 'file:') {
            alert('å»ºè­°ä½¿ç”¨æœ¬åœ°ä¼ºæœå™¨ï¼š\npython -m http.server 8000');
        }
    </script>
</body>
</html>